var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"] add https://github.com/JulienPascal/MSM.jl.git ","category":"page"},{"location":"gettingstarted/#Example","page":"Getting started","title":"Example","text":"","category":"section"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"MSMOptions","category":"page"},{"location":"functions/#MSM.MSMOptions","page":"Functions","title":"MSM.MSMOptions","text":"MSMOptions\n\nMSMOptions is a mutable struct that contains options related to the optimization.\n\n\n\n\n\n","category":"type"},{"location":"functions/","page":"Functions","title":"Functions","text":"Estimate a model with a maximum of 1000 function evaluations (only relevant for the global optimizer). Set the global optimizer to be :dxnes and the local otimizer to be :LBFGS. Global optimizers can be chosen from BlackBoxOptim.jl and local optimizers from Optim.jl.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"options = MSMOptions(maxFuncEvals=1000, globalOptimizer = :dxnes, localOptimizer = :LBFGS);","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"This package is still in its development phase. Yet, if you feel brave enough:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add https://github.com/JulienPascal/MSM.jl.git","category":"page"},{"location":"#MSM.jl","page":"Home","title":"MSM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: codecov.io) (Image: Coverage Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"MSM.jl is a package designed to facilitate the estimation of economic models via the Method of Simulated Moments.","category":"page"},{"location":"#Why","page":"Home","title":"Why","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An economic theory can be written as a system of equations that depends on primitive parameters. The aim of the econometrician is to recover the unknown parameters using empirical data. One popular approach is to maximize the likelihood funtion. Yet in many instances, the likelihood function is intractable. An alternative approach to estimate the unknown parameters is to minimize a (weighted) distance between the empirical moments and their theoretical counterparts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the function mapping the set of parameter values to the theoretical moments (the expected response function) is known, this method is called the Generalized Method of Moments. However, in many interesting cases the expected response function is unknown. This issue may be circumvented by simulating the expected response function, which is often an easy task. In this case, the method is called the Method of Simulated Moments.","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MSM.jl is being developed with the following constraints in mind:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parallelization within the expected response function is difficult","category":"page"},{"location":"","page":"Home","title":"Home","text":"to achieve. This is generally the case when working with the simulated method of moments, as the simulated time series are often serially correlated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus, the minimizing algorithm should be able to run in parallel\nThe minimizing algorithm should search for a global minimum, as the","category":"page"},{"location":"","page":"Home","title":"Home","text":"objective function may have multiple local minima.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Do not reinvent the wheel. Excellent minimization packages already exist in","category":"page"},{"location":"","page":"Home","title":"Home","text":"the Julia ecosystem. This is why MSM.jl relies on BlackBoxOptim.jl and Optim.jl to perform the minimization.","category":"page"}]
}
